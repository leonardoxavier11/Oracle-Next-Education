Você precisará criar a entidade Paciente:

@Getter
@EqualsAndHashCode(of = "id")
@NoArgsConstructor
@AllArgsConstructor
@Entity(name = "Paciente")
@Table(name = "pacientes")
public class Paciente {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private String email;
    private String cpf;
    private String telefone;

    @Embedded
    private Endereco endereco;

    public Paciente(DadosCadastroPaciente dados) {
        this.nome = dados.nome();
        this.email = dados.email();
        this.telefone = dados.telefone();
        this.cpf = dados.cpf();
        this.endereco = new Endereco(dados.endereco());
    }

}

Na sequência, precisará criar um repository:

public interface PacienteRepository extends JpaRepository<Paciente, Long> {
}COPIAR CÓDIGO
Depois, precisará alterar as classes Controller e DTO:

@RestController
@RequestMapping("pacientes")
public class PacienteController {

    @Autowired
    private PacienteRepository repository;

    @PostMapping
    @Transactional
    public void cadastrar(@RequestBody @Valid DadosCadastroPaciente dados) {
        repository.save(new Paciente(dados));
    }


public record DadosCadastroPaciente(
        @NotBlank String nome,
        @NotBlank @Email String email,
        @NotBlank String telefone,
        @NotBlank @Pattern(regexp = "\\d{3}\\.?\\d{3}\\.?\\d{3}\\-?\\d{2}") String cpf,
        @NotNull @Valid DadosEndereco endereco
) {
}

E, por fim, vai precisar criar uma migration (Atenção! Lembre-se de parar o projeto antes de criar a migration!):

create table pacientes(
    id bigint not null auto_increment,
    nome varchar(100) not null,
    email varchar(100) not null unique,
    cpf varchar(14) not null unique,
    telefone varchar(20) not null,
    logradouro varchar(100) not null,
    bairro varchar(100) not null,
    cep varchar(9) not null,
    complemento varchar(100),
    numero varchar(20),
    uf char(2) not null,
    cidade varchar(100) not null,

    primary key(id)
);

Vamos analisar cada bloco de código separadamente:

Entidade Paciente:
A classe Paciente é uma entidade do Spring Framework, mapeada como uma entidade JPA (Java Persistence API) através das anotações @Entity e @Table. Essas anotações definem que a classe representa uma tabela no banco de dados com o nome "pacientes".
As demais anotações presentes na classe são:

@Getter: Essa anotação é do projeto Lombok e gera automaticamente os métodos getter para os campos da classe.
@EqualsAndHashCode: Também do projeto Lombok, essa anotação gera automaticamente os métodos equals() e hashCode() com base no campo "id".
@NoArgsConstructor e @AllArgsConstructor: São anotações do Lombok que geram automaticamente construtores sem argumentos (padrão) e um construtor com todos os campos da classe, respectivamente.
A classe possui os seguintes campos:

id: É a chave primária da tabela, gerada automaticamente pelo banco de dados através da anotação @Id e @GeneratedValue. O tipo é Long.
nome, email, cpf e telefone: São campos de informações pessoais do paciente, do tipo String.
endereco: É um campo do tipo Endereco, que representa a classe embutida Endereco. Isso é indicado pela anotação @Embedded.
Repository Paciente:
O PacienteRepository é uma interface que estende a interface JpaRepository do Spring Data JPA. Essa interface já possui métodos predefinidos para realizar operações de persistência no banco de dados, como salvar, atualizar, buscar e excluir registros. Nesse caso, a interface PacienteRepository herda esses métodos para a entidade Paciente e define o tipo da chave primária como Long.

Controller Paciente:
A classe PacienteController é um controlador Spring MVC, responsável por receber as requisições HTTP relacionadas aos pacientes. Essa classe é mapeada para o caminho "/pacientes" através da anotação @RequestMapping.

O controlador possui uma dependência injetada do tipo PacienteRepository através da anotação @Autowired, permitindo o acesso aos métodos de persistência.

O método cadastrar é mapeado para a rota POST "/pacientes" através da anotação @PostMapping. Ele recebe um objeto DadosCadastroPaciente no corpo da requisição, validado pela anotação @Valid.

Dentro do método, é criado um novo objeto Paciente com base nos dados recebidos e é salvo no banco de dados utilizando o método repository.save().

DTO DadosCadastroPaciente:
A classe DadosCadastroPaciente é um DTO (Data Transfer Object) que representa os dados recebidos no momento do cadastro de um paciente. É anotada com @Valid para realizar validações de dados.
Os campos nome, email, telefone, cpf são de tipos String e estão anotados com validações específicas como @NotBlank, @Email e @Pattern para garantir que os dados atendam aos critérios definidos.

O campo endereco é do tipo DadosEndereco, que representa outro DTO contendo informações sobre o endereço.

Este bloco de código é uma instrução SQL para criar a tabela "pacientes" no banco de dados. A tabela possui as seguintes colunas:
id: Chave primária, do tipo bigint (inteiro longo), com a opção not null (não pode ser nulo).
nome: Coluna do tipo varchar(100) (cadeia de caracteres de até 100 caracteres), também com a opção not null.
email: Coluna do tipo varchar(100), com a opção not null e unique (valor único).
cpf: Coluna do tipo varchar(14), com a opção not null e unique.
telefone: Coluna do tipo varchar(20), com a opção not null.
logradouro: Coluna do tipo varchar(100), com a opção not null.
bairro: Coluna do tipo varchar(100), com a opção not null.
cep: Coluna do tipo varchar(9), com a opção not null.
complemento: Coluna do tipo varchar(100), que permite nulos.
numero: Coluna do tipo varchar(20), que permite nulos.
uf: Coluna do tipo char(2), com a opção not null.
cidade: Coluna do tipo varchar(100), com a opção not null.

Além disso, a coluna id é definida como chave primária (primary key) para identificar de forma única cada registro na tabela.

Essa migração representa a estrutura da tabela "pacientes" que será criada no banco de dados quando executada.